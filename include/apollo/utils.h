/**
 * @file utils.h
 * @brief utils functions
 * @author zhenkai.sun
 */
#pragma once
extern "C" {
#include <openssl/bio.h>
#include <openssl/buffer.h>
#include <openssl/evp.h>
#include <openssl/hmac.h>
}
// sys
#include <sstream>
#include <stdexcept>
#include <string>
#include <unordered_map>
#include <vector>

namespace apollo {
extern const char *HMAC_SHA1_SIGN_DELIMITER;

int64_t CurrentMilliseconds();

/**
 * @brief Calculate HmacSha1Sign with secret key
 * @param [in] raw raw data need to be encoded
 * @param [in] key secret key
 * @note: The implemention cod of this function is completely generated by
 * deepseek-r1
 * */
template <typename S1, typename S2>
std::string HmacSha1Sign(const S1 &raw, const S2 &key) {
  // 创建 EVP_MAC 对象
  EVP_MAC *mac = EVP_MAC_fetch(nullptr, "HMAC", nullptr);
  if (!mac) {
    throw std::runtime_error("Failed to fetch EVP_MAC for HMAC");
  }

  EVP_MAC_CTX *ctx = EVP_MAC_CTX_new(mac);
  EVP_MAC_free(mac);
  if (!ctx) {
    throw std::runtime_error("Failed to create EVP_MAC_CTX");
  }

  // 设置参数
  OSSL_PARAM params[] = {OSSL_PARAM_utf8_string("digest", const_cast<char *>("SHA1"), 0), OSSL_PARAM_END};

  // 初始化 HMAC 上下文
  if (EVP_MAC_init(ctx, reinterpret_cast<const unsigned char *>(key.data()), key.size(), params) != 1) {
    EVP_MAC_CTX_free(ctx);
    throw std::runtime_error("EVP_MAC_init failed");
  }

  // 更新数据
  if (EVP_MAC_update(ctx, reinterpret_cast<const unsigned char *>(raw.data()), raw.size()) != 1) {
    EVP_MAC_CTX_free(ctx);
    throw std::runtime_error("EVP_MAC_update failed");
  }

  // 获取摘要
  unsigned char out[EVP_MAX_MD_SIZE];
  size_t out_len = 0;
  if (EVP_MAC_final(ctx, out, &out_len, sizeof(out)) != 1) {
    EVP_MAC_CTX_free(ctx);
    throw std::runtime_error("EVP_MAC_final failed");
  }

  EVP_MAC_CTX_free(ctx);

  // Base64 编码
  BIO *bio = BIO_new(BIO_f_base64());
  BIO *bmem = BIO_new(BIO_s_mem());
  bio = BIO_push(bio, bmem);

  BIO_set_flags(bio, BIO_FLAGS_BASE64_NO_NL);
  BIO_write(bio, out, out_len);
  BIO_flush(bio);

  BUF_MEM *bptr;
  BIO_get_mem_ptr(bio, &bptr);

  std::string result(bptr->data, bptr->length);
  BIO_free_all(bio);

  return result;
}

template <typename T>
std::string ToString(const std::vector<T> &v) {
  std::stringstream ss;
  ss << "[";
  for (int i = 0; i < v.size(); ++i) {
    if (i != 0) ss << ",";
    ss << v[i];
  }
  ss << "]";
  return ss.str();
}

template <typename K, typename V>
std::string ToString(const std::unordered_map<K, V> &m) {
  std::stringstream ss;
  ss << "{";
  for (auto it = m.begin(); it != m.end(); ++it) {
    if (it != m.begin()) ss << ",";
    ss << "\"" << it->first << "\":" << "\"" << it->second << "\"";
  }
  ss << "}";
  return ss.str();
}
}  // namespace apollo
